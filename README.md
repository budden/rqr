# rqr
rqr = (http) requester

# Замечания о выполнении задания
> Список просьб должен сохраняться на сервере, например в map.

Не сказано, должен ли сохраняться список просьб вместе с результатом, и что делать 
с некорректными просьбами (содержащими неверную структуру запроса или такие, которые
нам не удалось выполнять). При реальной работе мы бы обратились к автору задания, 
а данное задание - тестовое. Было принято решение действовать простейшим образом - 
сохранять только успешно выполненные просьбы (например, если произошла ошибка при
чтении запроса, мы не считаем это успехом), причём сохранять их вместе с нашим ответом. 

Также неясно, что делать при повторном поступлении идентичной просьбы. Мы не пытаемся
найти подобную просьбу, а выполняем просьбу заново. 

> Задача предполагает, что кандидат покажет знание перечисленных выше пунктов за исключением, может быть, goroutine/chan/sync.Mutex. 

Поскольку http порождает горутины для обработки http запросов, мьютекс необходим
для выполнения задания. 

> Так же мы хотели бы увидеть код приближённый к продакшн версии с понятными наименованиями переменных и http route-ов

Мы назвали просьбу fetchtask. В роутах можно было назвать её fetch-task, но мы выбрали название без чёрточек, чтобы можно было грепом найти все вхождения слова fetchtask, будь то маршрут или имя переменной. По этой же причине не получилось взять fetch_task - линтер ругается на подчёркивания в именах переменных golang. fetchTask мы тоже не стали применять, т.к. смешанный регистр не может применяться в именах файлов и не особо хорош в URL-ах. Поэтому получилось fetchtask, что не слишком хорошо читается. 


# Запуск и тестирование
см. [testing.md](testing.md)

# Что продемонстрировано

* ✓ описание структур данных
* ✓ использование интерфейсов 
* ± обработка ошибок  (кроме panic/recover())
* ✓ работа с json 
* ✓ обработка http запросов 
* ✓ использование http.Client 
* ✓ использование стандартных структур данных map/slice 
* ± goroutine/chan/sync.Mutex (только sync.Mutex)
